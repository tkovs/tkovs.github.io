<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="hsl(35, 36%, 95%)">

  <title>Conceitos da programação funcional</title>

  
  <meta name="description" content="
  
    Conceitos da programação funcional
    
    April 21, 2016 in Programação
    
      
        
      
    
  



  
    
      
      Para ..." />

  
  <meta name="keywords" content="" />

  <link rel="canonical" href="http://tkovs.me/blog/2016/04/21/programacao-funcional/">
  <link rel="alternate" type="application/rss+xml" title="Informática, Matemática e afins" href="http://tkovs.me/feed.xml" />
  <span itemprop='author'><meta name="author" content="João Vitor Rodrigues da Silva"><span itemprop='author'></span>

  <link rel="stylesheet" href="//brick.a.ssl.fastly.net/PT+Serif:400,400i,700,700i:f">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">

  <link rel="stylesheet" href="/css/main.css">

  <script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
      },

      TeX: {
        equationNumbers: { autoNumber: "AMS" }
      },

      CommonHTML: {
        scale: 90
      }
    });
  </script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-69060-5', 'auto');
    ga('send', 'pageview');
  </script>

  <script src="https://d3js.org/d3.v4.min.js"></script>
  <script src="https://d3js.org/d3-hexbin.v0.2.min.js"></script>
  <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js"></script>
  <script src="https://use.fontawesome.com/4bee85bf94.js"></script>

  
</head>

  <body>
    <div class="container main">
      <div class="row navbar">
    <div class="col-6">
        
        <a class="fa fa-github" href="https://github.com/tkovs" title="GitHub"></a>
          
        <a class="fa fa-linkedin" href="https://id.linkedin.com/in/tkovs" title="LinkedIn"></a>
         
        <a class="fa fa-facebook" href="https://www.facebook.com/joaovitorIFAL" title="Facebook"></a>
          
        <a class="fa fa-instagram" href="https://www.instagram.com/_tkovs" title="Instagram"></a>
        
    </div>
    <div class="col-6 text-right">
        <a class="fa fa-home" href="/"></a>
    </div>
</div>
      <div class="row justify-content-center">
  <header class="col-md-12 text-center mt-3">
    <h1 itemprop="name" class="pl-3 pr-3">Conceitos da programação funcional</h1>
    
    <p>April 21, 2016 in Programação</p>
    <div class="small-ornament pt-3 pb-3">
      <svg viewBox="0 100 290 220">
        <path d="M280.3 245.4Q280.3 263.3 261.8 272 247.9 278.7 227.8 278.7 235.3 269.9 235.3 256.5 235.3 231.9 214.5 217.1 196 204 170.3 204 143.6 204 108.8 221.1L119 231.5Q154.4 267.9 168.3 267.9 181.1 267.9 181.1 255.9 181.1 248.3 173.5 243.6 167.1 239.3 159 239.3 154.7 239.3 148.6 241.5 158.6 220.1 174 220.1 184.5 220.1 191.9 228.1 199.3 236.1 199.3 246.7 199.3 265.5 184.4 277.9 170.3 289.4 151 289.4 118.7 289.4 81.4 251L72.1 241.5Q53.6 249.5 39.4 249.5 26.4 249.5 17.2 241 7.9 232.5 7.9 219.5 7.9 203.9 19.1 193.9 30 184.5 45.8 184.5 70 184.5 98.3 211.6 111.5 202.2 127.5 185.5L134.6 178.2Q174.5 136.7 204.9 136.7 231.5 136.7 231.5 155.3 231.5 173.5 204.3 177.3 206.4 172.8 206.4 170.2 206.4 159.3 193.4 159.3 175.2 159.3 144.3 189L137.1 195.9Q165.2 185.8 191.3 185.8 221.8 185.8 248.3 200.1 280.3 217.3 280.3 245.4ZM61.2 230.5Q44.6 215.3 37.3 215.3 28 215.3 28 223.5 28 234.4 42.8 234.4 51.2 234.4 61.2 230.5z"/>
      </svg>
    </div>
  </header>
</div>

<div class="row justify-content-center">
  <div class="col-md-8">
    <article lang="en">
      
      <p>Para o desenvolvimento de softwares, existem linguagens de programação. Essas
linguagens podem ser classificadas e categorizadas de acordo com suas
funcionalidades. Essas classificações são chamadas de <strong>paradigmas de
programação</strong>.</p>

<p><img src="https://i.ytimg.com/vi/lqmMqtgWpms/maxresdefault.jpg" style="width: 100%" /></p>

<p>Um paradigma de programação define os recursos que uma linguagem de programação
disponibiliza, além do seu funcionamento, podendo essa linguagem estar embasada
em apenas um paradigma ou ser multiparadigma. Os paradigmas mais comuns são o 
<strong>orientado a objetos</strong>, o <strong>imperativo</strong>, e o <strong>funcional</strong> (abordado nessa
publicação).</p>

<p>Antes de começar a programar no paradigma funcional, é necessário compreender
alguns conceitos que serão abordados no decorrer do texto.</p>

<div id="id-haskell"></div>

<h2 id="haskell">Haskell</h2>

<p>A linguagem escolhida para demonstração de exemplos foi Haskell, uma linguagem puramente funcional,
sem side-effects nem dados mutáveis, baseada no <em>Lambda Calculus</em>. Em breve irei 
fazer o port para a linguagem Ruby ou Javascript dos códigos usados aqui, assim facilita o entendimento
para o maior público. Deixarei os exemplos em Haskell no post mas ficarão em segundo plano após o
port. 
Caso queira estudar Haskell por conta própria, recomendo os seguintes materiais:</p>

<ul>
  <li><a href="http://www.cs.nott.ac.uk/~pszgmh/book.html"><strong>Programming in Haskell</strong> <em>by Graham Hutton</em></a></li>
  <li><a href="https://wiki.haskell.org/"><strong>Wiki Haskell</strong></a></li>
</ul>

<div id="id-conceitos"></div>

<h2 id="conceitos">Conceitos</h2>

<p>Para compreender esse paradigma, alguns conceitos são fundamentais.</p>

<div id="id-funcoes-puras"></div>

<h4 id="funções-puras">Funções puras</h4>

<p class="text-center">
<img src="https://cdn-images-1.medium.com/max/1200/1*OmLtMy0P6aBQzfzbZewlAA.png" class="w-25" />
</p>

<p>
São funções sem side-effects - ou efeitos colaterais, em português. Elas não
dependem de nada além daquilo que é passado a elas como argumento e não influenciam diretamente o
resto do programa. Isso vai ao encontro da computação paralela, que é a divisão de uma tarefa entre
vários processadores, ou até mesmo máquinas. Um exemplo do porque programação funcional é bastante
relacionado à computação paralela é você ter uma lista de dados e precisar aplicar
uma função sobre todos os dados: pode-se dividir essa lista em listas menores e, tendo vários
processadores a disposição, atribuir uma lista a cada um e fazê-los trabalharem paralelamente,
otimizando a tarefa. Isso é completamente viável porque uma execução não vai influenciar em outra
paralela.
</p>

<div id="id-imutabilidade"></div>

<h4 id="imutabilidade">Imutabilidade</h4>

<blockquote>
  <p>“A programação orientada a objetos torna o código mais compreensível por meio da contenção de partes móveis. A programação funcional torna o código mais compreensível por meio da <strong>minimização</strong> de partes móveis”. – <a href="https://twitter.com/mfeathers/status/29581296216">Michael Feathers</a>, autor de Working with Legacy Code, no Twitter.</p>
</blockquote>

<p>Ao se definir o valor de um dado, ele não pode ter seu valor alterado. Ao invés
de se alterar o valor existe, cria-se uma cópia para se trabalhar, um dado novo, baseado no velho.
Ao manipular dados, você não precisa se preocupar em alterar dados, pois novos sempre são criados
quando você precisa fazer isso. Isso seria inviável na programação imperativa que se baseia em ações
e estruturas que modificam as variáveis que definem um programa.</p>

<p><strong>Exemplo de uso</strong>:</p>

<p>No exemplo abaixo, imagine que nesse programa escrito em C a variável <code class="highlighter-rouge">tamanho</code> já tenha sido
declarada e contenha o tamanho do <code class="highlighter-rouge">vetor</code>, e <code class="highlighter-rouge">soma</code> já tenha sido declarada anteriormente também. Se o
conteúdo do <code class="highlighter-rouge">vetor</code> for alterado por alguma ação <em>paralela</em> no resto do programa antes da soma terminar,
o resultado será incorreto.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="p">...</span>
<span class="p">...</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">indice</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">indice</span> <span class="o">&lt;</span> <span class="n">tamanho</span><span class="p">;</span> <span class="n">indice</span><span class="o">++</span><span class="p">)</span>
    <span class="n">soma</span> <span class="o">+=</span> <span class="n">vetor</span><span class="p">[</span><span class="n">indice</span><span class="p">]</span>
<span class="p">}</span>

<span class="n">printf</span> <span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="n">soma</span><span class="p">);</span>

<span class="p">...</span>
<span class="p">...</span></pre></td></tr></tbody></table></code></pre></figure>

<!-- Outro exemplo do uso de programação paralela é na renderização de imagens. Há milhões de pixels que
devem ser renderizados. Todos eles podem ser renderizados individualmente, sem depender um do outro.
A ideia é mais ou menos essa. Logo, dividir a tarefa agiliza o processo, -->

<div id="id-recursao"></div>

<h4 id="recursão">Recursão</h4>

<p>O único meio de iteração ao se programar funcionalmente é usando recursão.</p>

<p>Recursão em funções, na computação, é como definimos o comportamento de uma função que invoca a si mesma.
Devido ao paralelismo, o resultado é otimizado, porém como recursão está em constante uso, as vezes
acaba pesando, mesmo com os recursos de otimização, por isso há outros meios que contribuem para 
isso, como por exemplo usar recursão de cauda.</p>

<p>Mas antes de entrar nesse assunto, será demonstrado aqui o uso da recursão para funções comuns.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre><span class="c1">-- Soma de uma lista</span>
<span class="n">sum</span> <span class="o">::</span> <span class="p">[</span><span class="kt">Num</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="kt">Num</span>
<span class="n">sum</span> <span class="kt">[]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">sum</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">sum</span> <span class="n">xs</span>

<span class="c1">-- Funcionamento</span>
<span class="c1">-- sum [1,2,3,4,5]</span>
<span class="c1">-- 1 + sum [2,3,4,5]</span>
<span class="c1">-- 1 + 2 + sum [3,4,5]</span>
<span class="c1">-- 1 + 2 + 3 + sum [4,5]</span>
<span class="c1">-- 1 + 2 + 3 + 4 + sum [5]</span>
<span class="c1">-- 1 + 2 + 3 + 4 + 5 + sum []</span>
<span class="c1">-- 1 + 2 + 3 + 4 + 5 + 0</span>
<span class="c1">-- 15</span>

<span class="c1">-- Fatorial de um número</span>
<span class="n">fat</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">fat</span> <span class="mi">1</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">fat</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">fat</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="c1">-- Funcionamento</span>
<span class="c1">-- fat 5</span>
<span class="c1">-- 5 * fat 4</span>
<span class="c1">-- 5 * 4 * fat 3</span>
<span class="c1">-- 5 * 4 * 3 * fat 2</span>
<span class="c1">-- 5 * 4 * 3 * 2 * fat 1</span>
<span class="c1">-- 5 * 4 * 3 * 2 * 1</span>
<span class="c1">-- 120</span></pre></td></tr></tbody></table></code></pre></figure>

<p>Recursão de cauda, ou <strong>tail call</strong> em inglês, é como uma subcategoria da recursão, e é usada pois
na recursão comum o número de chamadas à função aumenta, consequentemente estourando a pilha.
Explicando isso de uma maneira simples: uma função com recursão de cauda é uma função onde a chamada
a si mesma ocorre apenas no final da função, não precisando manter na pilha de chamada os valores de
retorno. É verdade que funções recursivas podem ser mais custosas do que iterações, mas normalmente os
compiladores de linguagens funcionais transformam chamadas a funções com recursão de cauda em loops.</p>

<blockquote>
  <p>O código abaixo mostra a escrita e o funcionamento da função fibonacci sem usar tail call.</p>
</blockquote>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="c1">-- Fibonacci sem tail call</span>
<span class="n">fib</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">fib</span> <span class="mi">0</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">fib</span> <span class="mi">1</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">fib</span> <span class="n">x</span> <span class="o">=</span> <span class="n">fib</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>

<span class="cm">{-
-&gt; Execução do código acima para x = 6
-&gt; fib 6
-&gt; (fib 5) + (fib 4)
-&gt; ((fib 4) + (fib 3)) + ((fib 3) + (fib 2))
-&gt; (((fib 3) + (fib 2)) + ((fib 2) + (fib 1))) + (((fib 2) + (fib 1)) + ((fib 1) + (fib 0)))
-&gt; ((((fib 2) + (fib 1)) + ((fib 1) + (fib 0))) + (((fib 1) + (fib 0)) + 1)) + ((((fib 1) + (fib 0)) + 1) + (1 + 0))
-&gt; (((((fib 1) + (fib 0)) + 1) + (1 + 0)) + ((1 + 0) + 1)) + (((1 + 0) + 1) + (1 + 0))
-&gt; ((((1 + 0) + 1) + 1) + (1 + 1)) + ((1 + 1) + 1)
-&gt; (((1 + 1) + 1) + 2) + (2 + 1)
-&gt; ((2 + 1) + 2) + 3
-&gt; (3 + 2) + 3
-&gt; 5 + 3
-&gt; 8
-}</span></pre></td></tr></tbody></table></code></pre></figure>

<blockquote>
  <p>O código abaixo mostra a escrita e o funcionamento da função fibonacci usando tail call e uma função
auxiliar.</p>
</blockquote>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="c1">-- Fibonacci com tail call</span>
<span class="n">fib</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">fib</span> <span class="n">x</span> <span class="o">=</span> <span class="n">fib_aux</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">fib_aux</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">fib_aux</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span>    <span class="o">=</span> <span class="n">current</span>
<span class="n">fib_aux</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">next</span><span class="p">)</span> <span class="o">=</span> <span class="n">fib_aux</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">current</span> <span class="o">+</span> <span class="n">next</span><span class="p">)</span>

<span class="cm">{-
-&gt; Funcionamento
-&gt; fib 6
-&gt; fib_aux(6, 0, 1)
-&gt; fib_aux(5, 1, 1)
-&gt; fib_aux(4, 1, 2)
-&gt; fib_aux(3, 2, 3)
-&gt; fib_aux(2, 3, 5)
-&gt; fib_aux(1, 5, 8)
-&gt; fib_aux(0, 8, 13)
-&gt; 8
-}</span></pre></td></tr></tbody></table></code></pre></figure>

<div id="id-transparencia-referencial"></div>

<h4 id="transparência-referencial">Transparência referencial</h4>

<p>Não importa quantas vezes uma função seja chamada, se o parâmetro for
o mesmo o retorno também será, e a essa propriedade se dá o nome de transparência referencial.
Dessa forma, facilmente se prova que uma função está funcionando como
deveria, e consequentemente, constrói-se funções mais complexas e seguras. Isso parece óbvio, mas em
outros paradigmas, é comum a mesma expressão poder resultar em diferentes valores em diferentes
momentos dependendo do estado de execução do programa. Como o exemplo da <a href="https://wiki.haskell.org">wiki do
Haskell</a> mostra, se <code class="highlighter-rouge">y = f x</code> e <code class="highlighter-rouge">g = h y y</code>, poderia substituir y por f x
de modo que g fosse descrito por <code class="highlighter-rouge">g = h (f x) (f x)</code> e se obter o mesmo resultado.</p>

<div id="id-funcoes"></div>

<h4 id="funções">Funções</h4>

<p>Uma das características desse paradigma é que funções são cidadãs de primeira classe.
Isso implica no fato de que funções não são usadas apenas para serem declaradas e chamadas. Elas
agora suportam muitas operações comuns a outros objetos, como serem passadas para funções como
parâmetros, serem retornadas por funções, e serem atribuídas a uma variável.
Daí, temos 2 conceitos novos: <strong>high order functions</strong> e <strong>currying</strong>. Esses dois termos
podem ser confundidos mas a verdade é que estão intrisecamente ligados: uma high order function é
uma função que recebe uma função como parâmetro, enquanto curried functions são funções que retornam
funções como parâmetros.
Através desse recurso, qualquer função com múltiplos parâmetros pode ser escrita com apenas um. Para
exemplo será usado o código abaixo:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="n">add</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-</span> <span class="p">(</span><span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span><span class="p">)</span>
<span class="n">add</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span></pre></td></tr></tbody></table></code></pre></figure>

<p>Observando a declaração da função, ela recebe 1 inteiro e retorna uma função que recebe um inteiro e
retorna outro inteiro. No corpo da função diz-se que recebe 2 parâmetros e retorna a soma deles.
Isso ocorre porque a função acima recebe um inteiro e retorna uma função, que recebe um inteiro y e
retorna o resultado de x + y.</p>

<p>Com esses recursos é possível escrever funções definitivamente úteis que são muito comuns em linguagens
funcionais e que costumam receber um port para a biblioteca padrão de linguagens não funcionais. Entre elas, há a
função map é uma função para manipulação de listas. Ela recebe uma função e uma lista genérica,
aplica a função sobre cada elemento da lista retornando uma nova lista com as modificações.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="c1">-- Usando recursão</span>
<span class="n">map</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
<span class="n">map</span> <span class="n">f</span> <span class="kt">[]</span>     <span class="o">=</span> <span class="kt">[]</span>
<span class="n">map</span> <span class="n">f</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">f</span> <span class="n">x</span> <span class="o">:</span> <span class="n">map</span> <span class="n">f</span> <span class="n">xs</span>

<span class="c1">-- Usando list comprehension</span>
<span class="n">map</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
<span class="n">map</span> <span class="n">f</span> <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">xs</span><span class="p">]</span></pre></td></tr></tbody></table></code></pre></figure>

<div id="id-funcoes-anonimas"></div>

<h4 id="funções-anônimas">Funções anônimas</h4>

<p>Conforme já vimos, funções são cidadãs de primeira classe. Valores de vários tipos podem ser
escritos de forma literal, sem obrigação de ser dar um nome, por exemplo <code class="highlighter-rouge">10</code> <code class="highlighter-rouge">"Vitor"</code>
<code class="highlighter-rouge">[1,2,3]</code>, e agora funções também, que no caso de haskell ficaria assim: <code class="highlighter-rouge">\x -&gt; 2 * x</code> - uma
função que recebe um valor e retorna seu dobro. Funções anônimas apenas são funções sem nome, também
conhecidas como <strong>lambda functions</strong>.</p>

<p>São usadas para conter uma funcionalidade que não precisa de um nome ou que tem um uso muito
curto e rápido, sendo um objeto temporário. Esse recurso evita a escrita de funções de uma linha só
que seriam usadas apenas uma vez, por exemplo:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="n">something</span> <span class="o">::</span> <span class="kt">Num</span> <span class="n">x</span> <span class="o">=&gt;</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span>
<span class="n">something</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span>

<span class="n">map</span> <span class="n">something</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="c1">-- Retorno: [5,16,33]</span></pre></td></tr></tbody></table></code></pre></figure>

<p>ficaria assim:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="c1">-- Retorno: [5,16,33]</span></pre></td></tr></tbody></table></code></pre></figure>

<div id="id-avaliacao-preguicosa"></div>

<h4 id="avaliação-preguiçosa">Avaliação preguiçosa</h4>

<p>Lazy Evaluation. Em breve.</p>

<div id="id-o-que-e"></div>

<h2 id="então-o-que-é-programação-funcional">Então, o que é programação funcional?</h2>

<p>A programação funcional é um paradigma de programação que 
se baseia em funções e é muito semelhante à matemática. Até mesmo um
programa é uma função. Não há um identificador para o ponto de partida, como na linguagem C
onde se começa pela função main(). O retorno de uma função se baseia inteiramente no que lhe é
passado e o momento em que a mesma função é chamada não é importante. O software desenvolvido
segundo esse paradigma funciona através da interação entre essas funções que, devido ao paradigma,
focam no que se deve fazer e não como fazer para se chegar ao resultado. Ou seja, o objetivo é
definir uma função que, trabalhando em cima de outras funções, vistas como expressões, gere um 
valor de retorno.</p>

<p>Você pode escrever código funcional em qualquer linguagem que dê suporte à funções de primeira
classe, como Ruby e Javascript, mas há linguagens focadas nisso, como Haskell e Elixir.</p>

<p>Há um nível de abstração muito alto, principalmente quando funções são utilizadas, e devido
à modularização, o código cresce rápido e de forma segura, de forma que a escrita de grandes funções
se dá através da composição de funções menores, o que evita a reescrita.
Os programas podem ser avaliados em diferentes ordens pois não há dependência nas operações de
atribuição, o que também garante aos programas serem mais simples de se provar e analisar 
matematicamente do que programas procedurais.</p>

<p>Como as funções são mais fáceis de serem avaliadas isoladamente, é mais fácil encontrar erros e
bugs e, aliás, contribuir com projetos open-source, mesmo sem um grande envolvimento.</p>

<p>Códigos funcionais são, geralmente, mais curtos e mais fáceis de entender do que sua 
implementação no
paradigma imperativo. É muito mais fácil de se trabalhar com paralelização de tarefas devido à
imutabilidade e às funções puras. O resultado final é um código bastante modularizado e conciso,
e sua manutenção é muito mais fácil do que em um código que permite side-effects e trabalha com
dados mutáveis, assim como a otimização do código e trabalho e equipe se tornam mais simples.</p>

<div id="id-uso"></div>

<h2 id="uso">Uso</h2>

<p>O sistema operacional <strong><a href="http://homepages.inf.ed.ac.uk/wadler/realworld/linspire.html">Linspire</a></strong>, baseado no Debian, tem uma equipe que trabalha usando programação
funcional em algumas tarefas como a <strong>detecção de hardware</strong>, <strong>criação de CDs de instalação</strong> e
<strong>aplicações web internas</strong>. Inicialmente usaram OCaml, depois decidiram por usar Haskell também.</p>

<p>O <strong><a href="http://xmonad.org/">xmonad</a></strong>, um gerenciador de janelas “tile-based” dinâmico para o X foi completamente desenvolvido
usando Haskell.</p>

<p>O <strong><a href="http://darcs.net/">Darcs</a></strong>, um software para controle de versão distribuida, assim como o git e o svn, 
com muitos recursos, que inicialmente foi escrito em C++, mas logo depois foi portado pra Haskell.</p>

<p><strong><a href="http://pandoc.org">Pandoc</a></strong>, uma ferramenta para conversão de um arquivo num formato de marcação para outro. Suporta
HTML, LaTeX, OPML, Org-mode, DocBook, Wiki markup, inDesign ICML, ebooks, e vários formatos TeX.
Desenvolvido em Haskell.</p>

<p>O Facebook tem a implementação de um
<strong><a href="http://www.wired.com/2015/09/facebooks-new-anti-spam-system-hints-future-coding/">anti-spam</a></strong> feita em Haskel.</p>

<p><strong><a href="http://www.yesodweb.com/">Yesod</a></strong>, uma framework para aplicações web de alta performance e alto
nível, com performance próxima à do C com acesso direto à memória. Desenvolvida em Haskell.</p>

<p>A linguagem de programação <strong><a href="http://hacklang.org/">Hack</a></strong>, desenvolvida pelo Facebook, é um
dialeto do PHP. Sua implementação é open-source, e seu compilador foi escrito em OCaml.</p>

<p>Há o <a href="0install.net"><strong>Zero Install (0Install)</strong></a> é um gerenciador de pacotes multiplataforma,
desenvolvido em OCaml. Se você tem um web-site, você pode distribuir seu software criando um pacote
que funciona em qualquer lugar, com manipulamento de dependências e atualizações automáticas.</p>

<p><strong><a href="http://frama-c.com/">FramaC</a></strong> é uma framework para analise modular de programas escritos em C.
Um analisador estático que ispenciona programas sem executalos. Implementada em OCaml.</p>

<p><strong><a href="http://haxe.org/">Haxe</a></strong> é uma linguagem de programação de alto nível e multiplataforma com um
compilador que produz aplicações e código fonte para diferentes plataformas através de um código
base. Seu commpilador é escrito em OCaml.</p>

<p>Para mais exemplos, há o link abaixo que reune programas escritos no paradigma funcional aplicados
em tarefas do mundo real. Entre as linguagens citadas na lista, há Clean, Haskell, Miranda, Scheme,
SML e Erlang.</p>

<p><a href="http://homepages.inf.ed.ac.uk/wadler/realworld/index.html">Functional Programming in the Real
World</a></p>

<h2 id="referências">Referências</h2>

<ul>
  <li><a href="http://din.uem.br/ia/ferramentas/lisp/lisp3.htm">Departamento de Informática (DIN) da Universidade Estadual de Maringá (UEM)</a></li>
  <li><a href="http://www.cs.nott.ac.uk/~pszgmh/book.html"><strong>Programming in Haskell</strong> <em>by Graham Hutton</em></a></li>
  <li><a href="https://wiki.haskell.org/Functional_programming">Wiki Haskell</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Functional_programming">Wikipedia</a></li>
  <li><a href="https://www.smashingmagazine.com/2014/07/dont-be-scared-of-functional-programming/">Smashing Magazine</a></li>
  <li><a href="http://pt.stackoverflow.com/questions/13372/programa%C3%A7%C3%A3o-funcional-e-programa%C3%A7%C3%A3o-orientada-a-objetos-o-que-s%C3%A3o-e-quais-suas">StackOverflow</a></li>
  <li><a href="http://blog.caelum.com.br/comecando-com-o-calculo-lambda-e-a-programacao-funcional-de-verdade/">Caelum</a></li>
  <li><a href="http://www2.ic.uff.br/~bazilio/cursos/lp/material/ProgFuncional.pdf">Instituto de Computação UFF</a></li>
</ul>



<div class="comments">
        <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'tkovsblog';

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] ||
        document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments
powered by Disqus.</a></noscript>

</div>

    </article>
  </div>
</div>

    </div>
    <footer class="mb-3">
  <div class="container">
    <div class="row biography">
      <div class="col-sm-6">
        <h2>quem eu sou</h2>
        <p>Eu sou graduando de Ciência da Computação pela <a href='http://www.ufal.edu.br/'>Universidade Federal de Alagoas</a>, técnico em Informática pelo <a href='https://www2.ifal.edu.br/'>Instituto Federal de Alagoas</a>, desenvolvedor web na <a href='https://plussoft.com.br'>PlusSoft</a>, entusiasta <a href='https://github.com/tkovs'>opensource</a>, e agora escritor em um blog.</p>
      </div>
      <div class="col-sm-6">
        <h2>o que é isto</h2>
        <p>Esse é um blog sobre desenvolvimento de softwares, matemática, estatística, e outros assuntos relacionados ao curso de Ciência da Computação.</p>
      </div>
    </div>
    
    <div class="row copyright text-center">
      <div class="col-sm-12">© 2018 João Vitor Rodrigues da Silva.<br>Conteúdo sobre <a href='https://mit-license.org/'>MIT License</a>.<br>Este site está hospedado no <a href='https://pages.github.com/'>Github Pages</a> e foi baseado no site do <a href='http://hugosereno.eu/'>Hugo Sereno</a> usando <a href='https://jekyllrb.com/'>Jekyll</a> e <a href='http://getbootstrap.com'>Bootstrap</a>.</div>
    </div>
    
  </div>
</footer>

  </body>

  
</html>
